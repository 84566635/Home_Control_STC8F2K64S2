C51 COMPILER V9.00   RS485                                                                 10/15/2018 14:10:31 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE RS485
OBJECT MODULE PLACED IN ..\Output\rs485.obj
COMPILER INVOKED BY: D:\Keil_v514\C51\BIN\C51.EXE ..\User\rs485.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(..\L
                    -isting\rs485.lst) TABS(2) OBJECT(..\Output\rs485.obj)

line level    source

   1          #include "rs485.h"
   2          #include "io.h"
   3          #include "relay.h"
   4          #include "delay.h"
   5          #include "crc8.h"
   6          #include <string.h>
   7          
   8          uint8_t Rx_Buffer[10] = {0};      //串口中断接收数据的Buffer
   9          uint8_t Rx_Cnt = 0;               //串口中断接收数据的数量
  10          
  11          /******************************************************************************
  12           函数: void RS485_Init(void)
  13           描述: RS485_usart初始化函数
  14           参数: 无
  15           返回: 无
  16          ******************************************************************************/
  17          void RS485_Init(void)
  18          { 
  19   1         AUXR1 &= 0X3F;    // #00xx xxxx [S1_S1:S1_S0] = [0:0],将串口1的TXD RXD引脚切换至P3.1 P3.0
  20   1        
  21   1         AUXR1 = 0x40;
  22   1      
  23   1         SCON = 0x50;      // #0101 0000 [SM0:SM1]=[0:0],串口1工作在模式1--10位串口通信，即1位起始位+8位数据位+1
             -位停止位，无校验位
  24   1        
  25   1         AUXR |= 0x05;     // #xxxx x1x1   定时器T2不分频，即工作在1T模式；
  26   1                           //              串口1选择定时器T2作为波特率发生器                
  27   1        
  28   1         AUXR &= 0xF7;     //#xxxx 0xxx  定时器T2用作定时器功能；
  29   1            
  30   1         T2L = 0XC0;       //通过给T2装初值确定串口1的波特率    
  31   1         T2H =  0XFD;
  32   1        
  33   1         AUXR |= 0x10;     //启动定时器T2
  34   1        
  35   1         ES = 1;           //开串口1中断
  36   1        
  37   1         EA = 1;           //开总中断
  38   1      }
  39          /******************************************************************************
  40           函数: void SerialPortInte(void)
  41           描述: 串口中断就收数据
  42           参数: 无
  43           返回: 无
  44          ******************************************************************************/
  45          void UART1(void) interrupt 4 
  46          { 
  47   1        if(RI)
  48   1        {
  49   2          RI=0;                                    //清零接收标志位
  50   2          
  51   2          Rx_Buffer[Rx_Cnt++]=SBUF;                     //读取缓冲区的数据
  52   2          
  53   2          if(Rx_Buffer[0] == 0xad)
C51 COMPILER V9.00   RS485                                                                 10/15/2018 14:10:31 PAGE 2   

  54   2          {
  55   3            if(Rx_Buffer[1] == 0xda)
  56   3            {
  57   4              if(Rx_Cnt == Rx_Buffer[2]+4)  
  58   4              {
  59   5                Analyse_Received_data(Rx_Buffer,Rx_Cnt);
  60   5                memset(Rx_Buffer,0,10);
  61   5                Rx_Cnt = 0;       
  62   5              }
  63   4              if(Rx_Cnt > (Rx_Buffer[2]+4))
  64   4              {
  65   5                memset(Rx_Buffer,0,10);
  66   5                Rx_Cnt = 0;           
  67   5              }       
  68   4            }
  69   3            else if(Rx_Cnt > 1)
  70   3            {
  71   4              memset(Rx_Buffer,0,10);
  72   4              Rx_Cnt = 0;       
  73   4            }
  74   3          }
  75   2          else
  76   2          {
  77   3            memset(Rx_Buffer,0,10);
  78   3            Rx_Cnt = 0;
  79   3          }
  80   2        }
  81   1      }
  82          
  83          /******************************************************************************
  84           函数: Send_data(u8 *buf,u16 len)
  85           描述: 将数据通过485串口发送出去
  86           参数: buf  需发送的数据数组
  87                 len  需发送数据的长度
  88           返回: 无
  89          ******************************************************************************/
  90          void Send_data(uint8_t *Send_Buffer,uint8_t Send_Cnt)
  91          {
  92   1        uint8_t Cnt;
  93   1      
  94   1        for(Cnt =0;Cnt < Send_Cnt;Cnt++)
  95   1        {
  96   2           SBUF = Send_Buffer[Cnt];                 //发送数据
  97   2           while(!TI);                  //等待发送完成
  98   2           TI=0;                        //清零发送标志位
  99   2        }
 100   1      }
 101          /******************************************************************************
 102           函数: int Analyse_Received_data(u8 *sub_string_buf,u16 len)
 103           描述: 解析收到的数据，是否帧头满足，是否crc满足
 104           参数: sub_string_buf  需解析的数据数组
 105                 len             需解析数据的长度
 106           返回: 数据是否有效  1，有效；0，无效
 107          ******************************************************************************/
 108          void  Analyse_Received_data(uint8_t *Analy_Buffer,uint8_t Analy_Cnt)
 109          {
 110   1        /*对收到的数据中附加的CRC码和本地根据收到的数据包算出的CRC码进行校验对比*/
 111   1        if(CRC8_Check(Analy_Cnt-1-3,Analy_Buffer+3) != Analy_Buffer[Analy_Cnt-1])
 112   1          return ;
 113   1        
 114   1        /*开始根据RS485传输的指令进行比对和处理*/  
 115   1        if(Analy_Buffer[3] == RS485_Addr)
C51 COMPILER V9.00   RS485                                                                 10/15/2018 14:10:31 PAGE 3   

 116   1        {             
 117   2          switch(Analy_Buffer[4])
 118   2          {             
 119   3            case 0x20:
 120   3              Device_Online_Count = 500;//5s
 121   3              IO_State_Convert();
 122   3              Relay_State_Conver(); 
 123   3              Response_IO_Relay_State(Analy_Buffer[4]);
 124   3              memset(IO_State_Buffer,0,2);
 125   3              memset(IO_Input_Lock,0,8);      
 126   3              break;
 127   3            case 0x60:                                               //查询调光值        
 128   3              UART_Cmd_Control_Relay(Analy_Buffer); 
 129   3              break;
 130   3           
 131   3            default:
 132   3              break;        
 133   3          }
 134   2        }
 135   1        else if(Analy_Buffer[3] == 0xff && Analy_Buffer[4] == 0xf0)       //查询本机地址的命令
 136   1        {
 137   2          Response_RS485_Adrress(Analy_Buffer[3],Analy_Buffer[4]); 
 138   2        }
 139   1      }
 140          
 141          /******************************************************************************
 142           函数: void Response_RS485_Adrress(uint8_t addr,uint8_t cmd)
 143           描述: 对查询RS485地址的命令进行回复
 144           参数: uint8_t addr   本模块RS485的地址
 145                 uint8_t cmd    地址查询的命令字
 146           返回: 无
 147          ******************************************************************************/
 148          
 149          void Response_RS485_Adrress(uint8_t addr,uint8_t cmd)
 150          {
 151   1        uint8_t Send_Temp[15]={0};
 152   1        uint8_t CRC_Temp[10]={0};
 153   1        Send_Temp[0]=0xad;
 154   1        CRC_Temp[0]=Send_Temp[0];
 155   1        
 156   1        Send_Temp[1]=0xda;
 157   1        CRC_Temp[1]=Send_Temp[1];
 158   1        
 159   1        Send_Temp[2]=0x03;
 160   1        CRC_Temp[2]=Send_Temp[2];  
 161   1        
 162   1        Send_Temp[3]=addr;
 163   1        CRC_Temp[3]=Send_Temp[3];
 164   1        
 165   1        Send_Temp[4]=cmd;
 166   1        CRC_Temp[4]=Send_Temp[4];
 167   1        
 168   1        Send_Temp[5]=Device_Mode;
 169   1        CRC_Temp[5]=Send_Temp[5];
 170   1        
 171   1        Send_Temp[6]=RS485_Addr;
 172   1        CRC_Temp[6]=Send_Temp[6];
 173   1        
 174   1        Send_Temp[2]=4;
 175   1        
 176   1        Send_Temp[7]=CRC8_Check(7,CRC_Temp);
 177   1      
C51 COMPILER V9.00   RS485                                                                 10/15/2018 14:10:31 PAGE 4   

 178   1        Send_data(Send_Temp,8);
 179   1      }
 180          
 181          /******************************************************************************
 182           函数: void UART_Cmd_Control_Relay(uint8_t *Cmd_Temp)
 183           描述: 通过命令对继电器进行控制
 184           参数: uint8_t *Cmd_Temp   继电器的控制指令buffer
 185           返回: 无
 186          ******************************************************************************/
 187          void UART_Cmd_Control_Relay(uint8_t *Cmd_Temp)
 188          { 
 189   1       if(Cmd_Temp[5] <= Device_Mode)
 190   1       {  
 191   2         Cmd_Control_Relay(Cmd_Temp);
 192   2         Response_Cmd_Control_Msg(Cmd_Temp[5]); 
 193   2       }
 194   1      }
 195          
 196          
 197          /******************************************************************************
 198           函数: void Response_Cmd_Control_Msg(uint8_t cmd)
 199           描述: 对控制继电器的命令进行回复
 200           参数: uint8_t cmd    继电器控制命令字
 201           返回: 无
 202          ******************************************************************************/
 203          void Response_Cmd_Control_Msg(uint8_t cmd)
 204          {
 205   1        uint8_t Send_Temp[15]={0};
 206   1        uint8_t CRC_Temp[10]={0};
 207   1        Send_Temp[0]=0xad;
 208   1        CRC_Temp[0]=Send_Temp[0];
 209   1        
 210   1        Send_Temp[1]=0xda;
 211   1        CRC_Temp[1]=Send_Temp[1];
 212   1        
 213   1        Send_Temp[2]=0x03;
 214   1        CRC_Temp[2]=Send_Temp[2];  
 215   1        
 216   1        Send_Temp[3]=RS485_Addr;
 217   1        CRC_Temp[3]=Send_Temp[3];
 218   1        
 219   1        Send_Temp[4]=cmd;
 220   1        CRC_Temp[4]=Send_Temp[4];
 221   1        
 222   1        Send_Temp[5]=Device_Mode;
 223   1        CRC_Temp[5]=Send_Temp[5];
 224   1        
 225   1        Send_Temp[2]=3;
 226   1        
 227   1        Send_Temp[6]=CRC8_Check(6,CRC_Temp);
 228   1      
 229   1        Send_data(Send_Temp,7);
 230   1      }
 231          
 232          /******************************************************************************
 233           函数: void Response_IO_Relay_State(uint8_t cmd)
 234           描述: 查询模块IO、IO使能拨码开关以及继电器的状态
 235           参数: uint8_t cmd    查询状态的命令字
 236           返回: 无
 237          ******************************************************************************/
 238          void Response_IO_Relay_State(uint8_t cmd)
 239          {
C51 COMPILER V9.00   RS485                                                                 10/15/2018 14:10:31 PAGE 5   

 240   1        uint8_t Send_Temp[15]={0};
 241   1        uint8_t CRC_Temp[10]={0};
 242   1        Send_Temp[0]=0xad;
 243   1        CRC_Temp[0]=Send_Temp[0];
 244   1        
 245   1        Send_Temp[1]=0xda;
 246   1        CRC_Temp[1]=Send_Temp[1];
 247   1        
 248   1        Send_Temp[2]=0x03;
 249   1        CRC_Temp[2]=Send_Temp[2];
 250   1        
 251   1        Send_Temp[3]=RS485_Addr;
 252   1        CRC_Temp[3]=Send_Temp[3];
 253   1        
 254   1        Send_Temp[4]=cmd;
 255   1        CRC_Temp[4]=Send_Temp[4];
 256   1        
 257   1        Send_Temp[5]=Device_Mode;
 258   1        CRC_Temp[5]=Send_Temp[5];
 259   1        
 260   1        Send_Temp[6]=IO_State_Buffer[1];
 261   1        CRC_Temp[6]=Send_Temp[6];
 262   1        
 263   1        Send_Temp[7]=IO_State_Buffer[0];
 264   1        CRC_Temp[7]=Send_Temp[7];
 265   1        
 266   1        Send_Temp[8]=Relay_State;
 267   1        CRC_Temp[8]=Send_Temp[8];
 268   1        
 269   1        Send_Temp[2]=6;
 270   1        
 271   1        Send_Temp[9]=CRC8_Check(9,CRC_Temp);
 272   1      
 273   1        Send_data(Send_Temp,10);
 274   1      }
 275          /**********************************THE END**********************************/ 
 276          
 277           


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    786    ----
   CONSTANT SIZE    =     75    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     11      89
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
